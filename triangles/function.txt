bool triangle_geometry::triangle_handler::is_intersect(const triangle &tr1, const triangle &tr2) const {
    if ( tr1.is_degenerate() ){
        /*
         * удаление вырожденного треугольника из базы данных
         */
    }
    if ( tr2.is_degenerate()){
        /*
         * удаление вырожденного треугольника из базы данных
         */
    }
    Plane plane_1 = Plane( tr1);
    int sign11, sign12, sign13;
    sign11 = triangle_handler::sign_of_dist(plane_1, tr2.getVertice(1));
    sign12 = triangle_handler::sign_of_dist(plane_1, tr2.getVertice(2));
    sign13 = triangle_handler::sign_of_dist(plane_1, tr2.getVertice(3));
    if ( sign11 * sign12 > 0 && sign11 * sign13 > 0) return false;//треугольник полностью с одной стороны от плоскости
    //else continue
    Vector3D edge00, edge01, edge10, edge11;
    Point p00, p01, p10, p11;//это точки для вычисления отрезков-проекций на линию пересечения
    p00 = tr1.getVertice(1);
    p01 = tr1.getVertice(3);
    if ( sign11 * sign12 < 0){//1 и 2 по разные стороны от плоскости
        edge00 = Vector3D(tr1.getVertice(1), tr1.getVertice(2));
        if ( sign11 * sign13 < 0){//1 и 3 по разные стороны от плоскости
            edge01 = Vector3D(tr1.getVertice(1), tr1.getVertice(3));
        }else{//1 и 3 по одну сторону от плоскости, с другой стороны - 2
            edge01 = Vector3D(tr1.getVertice(2), tr1.getVertice(3));
        }
    }else{//1 и 2 по одну сторону от плоскости
        edge00 = Vector3D(tr1.getVertice(1), tr1.getVertice(3));
        edge01 = Vector3D(tr1.getVertice(2), tr1.getVertice(3));
    }
    Plane plane_2 = Plane( tr2);
    if ( triangle_handler::is_coincident( plane_1, plane_2, tr1.getVertice(1), tr2.getVertice(1) )) {
        if (plane_1.get_d() == plane_2.get_d()) {
            if ( is_intersect2D(tr1, tr2)) return true;
            return false;
        }return false;//треугольники в параллельных плоскостях
    }//else continue
    int sign21, sign22, sign23; 
    sign21 = triangle_handler::sign_of_dist(plane_2, tr1.getVertice(1));
    sign22 = triangle_handler::sign_of_dist(plane_2, tr1.getVertice(2));
    sign23 = triangle_handler::sign_of_dist(plane_2, tr1.getVertice(3));
    if ( sign21 * sign22 > 0 && sign21 * sign23 > 0) return false;//треугольники полностью с одной стороны от плоскости
    //else continue
    p10 = tr2.getVertice(1);
    p11 = tr2.getVertice(3);
    if ( sign21 * sign22 < 0){//1 и 2 по разные стороны от плоскости
        edge00 = Vector3D(tr2.getVertice(1), tr2.getVertice(2));
        if ( sign21 * sign23 < 0){//1 и 3 по разные стороны от плоскости
            edge11 = Vector3D(tr2.getVertice(1), tr2.getVertice(3));
        }else{//1 и 3 по одну сторону от плоскости, с другой стороны - 2
            edge11 = Vector3D(tr2.getVertice(2), tr2.getVertice(3));
        }
    }else{//1 и 2 по одну сторону от плоскости
        edge10 = Vector3D(tr1.getVertice(1), tr1.getVertice(3));
        edge11 = Vector3D(tr1.getVertice(2), tr1.getVertice(3));
    }
    Line IntersectLine = triangle_handler::GetLine(plane_1, plane_2);
    Point t00, t01, t10, t11;//t0 - первый треугольник и его точки пересечения с прямой, t1 - второй треугольник
    t00 = IntersectionEdgeLine(p00, IntersectLine, edge00);
    t01 = IntersectionEdgeLine(p01, IntersectLine, edge01);
    t10 = IntersectionEdgeLine(p10, IntersectLine, edge10);
    t11 = IntersectionEdgeLine(p11, IntersectLine, edge11);
    double d1, d2, d3, d4, d5, d6;
}

triangle_geometry::Point triangle_geometry::triangle_handler::IntersectionEdgeLine(const Point& PointFromTriangle,const Line& line,
        const Vector3D& EdgeDir) const{
    Vector3D v(0, -EdgeDir.getZ(), EdgeDir.getY()), w( line.GetPoint(), PointFromTriangle);
    double s = -(v * w)/(v * line.Getdirection());
    return ( line.GetPoint() + s * line.Getdirection());
}